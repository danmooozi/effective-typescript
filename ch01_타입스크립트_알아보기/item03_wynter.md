## 앞장 그냥 정리

### 아이템1 타입스크립트와 자바스크립트의 관계 이해하기

* 타입 시스템의 목표 중 하나는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것입니다. 타입스크립트가 '정적'타입 시스템이라는 것은 바로 이런 특징을 말하는 것입니다.

* 타입스크립트는 자바스크립트의 상위집합입니다.

* 타입스크립트는 자바스크립트 런타임 동작을 모델링하는 타입 시스템을 가지고 있기 때문에 런타임 오류를 발생시키는 코드를 찾아내려고 합니다.

* 잘못된 매개변수 개수로 함수를 호출하는 경우처럼, 자스에서는 허용되지만 타스에서는 문제가 되는 경우도 있습니다. 이러한 문법의 엄격함은 온전히 취향의 차이이며 우열을 가릴 수 없는 문제입니다.

### 아이템2 타입스크립트 설정 이해하기

* 설정 파일 생성하기 `tsc --init`

* `noImplicitAny`: 변수들이 미리 정의된 타입을 가져야 하는지 여부 제어

* `strictNullChecks`: null과 undefined가 모든 타입에서 허용되는지 확인하는 설정

## 아이템3 코드 생성과 타입이 관계없음을 이해하기

> 💡 컴파일이란?
> 한 언어로 작성된 소스 코드를 다른 언어로 변환하는 것

> 💡 트랜스파일이란?
> 한 언어로 작성된 소스 코드를 비슷한 수준의 추상화를 가진 다른 언어로 변환하는 것

* 타입스크립트 컴파일러가 하는 일
    * 타스/자스를 브라우저에서 동작할 수 있도록 구버전의 자스로 트랜스파일
    * 코드의 타입 오류를 체크

* 컴파일과 타입체크는 독립적으로 동작한다.

> 💡 instanceof 연산자는 생성자의 prototype 속성이 객체의 프로토타입 체인 어딘가 존재하는지 판별

```ts
type Shape = Square | Rectangle;
function calculateArea(shape: Shape) {
    if(shape instanceof Rectangle)
        return shape.width * shape.height;
}
```

* 런타임에는 타입 체크가 불가능합니다.
    * instanceof로 인터페이스(Rectangle)에 해당하는지 확인하려고 했으나, 컴파일 과정에서 타입이 제거되어서 런타임 시점에는 아무 역할을 할 수 없었다.
    * shape가 해당 타입인지 체크하기 보다, 어떤 속성이 shape에 있는지 체크함으로써 해결 가능
    * 혹은 런타임에 접근 가능한 타입 정보를 명시적으로 저장하는 '태그'기법이 있다.
    * 또는 타입을 클래스로 만들면 된다.

```ts
type A = {
  kind: 'a';
  one: string;
  two: string;
  author: string;
};

type B = {
  kind: 'b';
  two: string;
  three: string;
  author: string;
};

type C = A | B;
```
* 태그된 유니온 기법 !
    * 한 번도 써 본 적도, 들어 본 적도 없었다.
    * 위에서 two라는 필드로는 A타입인지 B타입인지 알 수 없다.
    * kind(다른 키도 상관 없음)로 값을 구분하면 된다. `c.kind`
    
* 런타임 타입은 선언되 타입과 다를 수 있습니다
    * API와 같은 외부 의존성이 생긴 경우, 외부에서 제대로 된 값을 주지 않으면 달라진 수 있음

> 💡 함수 오버로딩이란? 동일한 이름에 매개 변수만 다른 여러 버전의 함수를 만드는 것.
> arrow function은 오버로딩을 할 수 없다.
> [[예시](https://lakelouise.tistory.com/194)]

* 타입스크립트 타입으로는 함수를 오버로드할 수 없습니다
    * 어차피 구현체 하나만 남게 되니까 타입으로 오버로드 해봤자...

* 타입스크립트 타입은 런타임 성능에 영향을 주지 않습니다
    * 빌드 타임엔 영향을 줌

## 뒷장 그냥 정리

### 아이템4 구조적 타이핑에 익숙해지기

> 💡 덕 타이핑이란?
> 객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주하는 방식

* 자스는 덕 타이핑 기반입니다.

* 아래의 경우 NamedVector 타입의 변수로도 함수를 사용할 수 있다.

```ts
interface Vector {
    x: number;
    y: number;
}

interface NamedVector {
    x: number; 
    y: number;
    name: string;
}

function cal(v: Vector) Math.sqrt(v.x * v.x + v.y * v.y);
```

* 이런 것을 타입이 열려(open)있다고 표현함

* 아래의 경우, 타입이 열려있기 때문에 axis가 어떤 값을 가질 지 몰라서 엘리먼트는 암시적으로 any 타입이 됨

```ts
function cal1(v:Vector3D) {
    let length = 0;
    for (const axis of Object.keys(v)) {
        const coord = v[axis];
        length += Math.abs(coord);
    }
    return length;
}
```

* 테스트를 작성할 때는 이 특성 때문에 구조적 타이핑이 유리
  * 사용되는 메서드만 대충 모킹할 수 있으니까.

### 아이템5 any 타입 지양하기

* any 타입에는 안전성이 없습니다.
    * `age='12'; age += 1`
    * age가 "121"

* any는 함수 시그니처를 무시해 버립니다.
  * 약속된 타입을 무시하고 넣을 수 있음

* any 타입에는 언어 서비스가 적용되지 않습니다.

* any 타입은 코드 리팩터링 때 버그를 감춥니다.

* any는 타입 설계를 감춰버립니다.

* any는 타입시스템의 신뢰도를 떨어뜨립니다.
