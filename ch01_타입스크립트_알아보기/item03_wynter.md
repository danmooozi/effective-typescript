## 앞장 그냥 정리

### 아이템1 타입스크립트와 자바스크립트의 관계 이해하기

* 타입 시스템의 목표 중 하나는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것입니다. 타입스크립트가 '정적'타입 시스템이라는 것은 바로 이런 특징을 말하는 것입니다.

* 타입스크립트는 자바스크립트의 상위집합입니다.

* 타입스크립트는 자바스크립트 런타임 동작을 모델링하는 타입 시스템을 가지고 있기 때문에 런타임 오류를 발생시키는 코드를 찾아내려고 합니다.

* 잘못된 매개변수 개수로 함수를 호출하는 경우처럼, 자스에서는 허용되지만 타스에서는 문제가 되는 경우도 있습니다. 이러한 문법의 엄격함은 온전히 취향의 차이이며 우열을 가릴 수 없는 문제입니다.

### 아이템2 타입스크립트 설정 이해하기

* 설정 파일 생성하기 `tsc --init`

* `noImplicitAny`: 변수들이 미리 정의된 타입을 가져야 하는지 여부 제어

* `strictNullChecks`: null과 undefined가 모든 타입에서 허용되는지 확인하는 설정

## 아이템3 코드 생성과 타입이 관계없음을 이해하기

> 💡 컴파일이란?
> 한 언어로 작성된 소스 코드를 다른 언어로 변환하는 것

> 💡 트랜스파일이란?
> 한 언어로 작성된 소스 코드를 비슷한 수준의 추상화를 가진 다른 언어로 변환하는 것

* 타입스크립트 컴파일러가 하는 일
    * 타스/자스를 브라우저에서 동작할 수 있도록 구버전의 자스로 트랜스파일
    * 코드의 타입 오류를 체크

* 컴파일과 타입체크는 독립적으로 동작한다.

> 💡 instanceof 연산자는 생성자의 prototype 속성이 객체의 프로토타입 체인 어딘가 존재하는지 판별

```ts
type Shape = Square | Rectangle;
function calculateArea(shape: Shape) {
    if(shape instanceof Rectangle)
        return shape.width * shape.height;
}
```

* 런타임에는 타입 체크가 불가능합니다.
    * instanceof로 인터페이스(Rectangle)에 해당하는지 확인하려고 했으나, 컴파일 과정에서 타입이 제거되어서 런타임 시점에는 아무 역할을 할 수 없었다.
    * shape가 해당 타입인지 체크하기 보다, 어떤 속성이 shape에 있는지 체크함으로써 해결 가능
    * 혹은 런타임에 접근 가능한 타입 정보를 명시적으로 저장하는 '태그'기법이 있다.
    * 또는 타입을 클래스로 만들면 된다.

```ts
type A = {
  kind: 'a';
  one: string;
  two: string;
  author: string;
};

type B = {
  kind: 'b';
  two: string;
  three: string;
  author: string;
};

type C = A | B;
```
* 태그된 유니온 기법 !
    * 한 번도 써 본 적도, 들어 본 적도 없었다.
    * 위에서 two라는 필드로는 A타입인지 B타입인지 알 수 없다.
    * kind(다른 키도 상관 없음)로 값을 구분하면 된다. `c.kind`
    
* 런타임 타입은 선언되 타입과 다를 수 있습니다
    * API와 같은 외부 의존성이 생긴 경우, 외부에서 제대로 된 값을 주지 않으면 달라진 수 있음

> 💡 동일한 이름에 매개 변수만 다른 여러 버전의 함수를 만드는 것.
> arrow function은 오버로딩을 할 수 없다.
> [[예시](https://lakelouise.tistory.com/194)]

* 타입스크립트 타입으로는 함수를 오버로드할 수 없습니다
    * 어차피 구현체 하나만 남게 되니까 타입으로 오버로드 해봤자...

* 타입스크립트 타입은 런타임 성능에 영향을 주지 않습니다
    * 빌드 타임엔 영향을 줌

